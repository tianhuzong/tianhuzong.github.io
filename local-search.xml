<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TinyToyCompiler 中间代码生成</title>
    <link href="/2024/12/21/CodeGen/"/>
    <url>/2024/12/21/CodeGen/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>TinyToyCompiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>TinyToyCompiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyToyCompiler 词法分析器</title>
    <link href="/2024/12/21/Lexer/"/>
    <url>/2024/12/21/Lexer/</url>
    
    <content type="html"><![CDATA[<h1 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h1><ul><li>本章节将介绍词法分析器的设计和实现。</li><li>代码传送门: <a href="https://github.com/tianhuzong/TinyToyCompiler/blob/main/lexer.l">lexer.l</a></li></ul><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析是计算机科学中将字符序列转换为单词序列的过程。<br>最常见的方法就是使用正则表达式匹配。<br>例如：<a href="https://docs.python.org/zh-cn/3.13/library/re.html#writing-a-tokenizer">正则表达式写一个词法分析器</a></p><h2 id="Flex"><a href="#Flex" class="headerlink" title="Flex"></a>Flex</h2><p>Flex 是一款开源的词法分析器生成器，它可以用正则表达式来匹配输入的字符序列，并生成相应的词法分析器。</p><p>Flex文件包括：</p><ul><li>定义部分：引入头文件 ，声明全局变量和全局表达式。</li><li>规则部分：定义规则，每个规则定义了如何匹配输入的字符序列。</li></ul><h3 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h3><p>定义部分包括<code>%&#123;... %&#125;</code>和规则部分中间的一部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs flex">%&#123;<br>    #include &lt;iostream&gt;<br>    #include &lt;string&gt;<br>    #include &lt;stdio.h&gt;<br>    #include &quot;Node.h&quot;<br>    #include &quot;parser.hpp&quot;<br><br>    using namespace std;<br>    #define TOKEN(t) return yylval.token = t<br>    #define SAVE_TOKEN yylval.name = new string(yytext)<br>%&#125;<br><br>%option noyywrap<br>%option yylineno<br></code></pre></td></tr></table></figure><p>上面定义了两个宏, <code>TOKEN</code>用来返回一个token类型, <code>SAVE_TOKEN</code>用来保存当前匹配到的字符串。</p><p>那些%option是什么意思呢？<br>我也不大清楚,感兴趣的可以上网查一下。</p><h3 id="规则部分"><a href="#规则部分" class="headerlink" title="规则部分"></a>规则部分</h3><p>规则部分定义了如何匹配输入的字符序列。<br>规则部分都是以<code>正则表达式 &#123;动作&#125;</code>的形式定义的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs flex">%%<br><br>&quot;int&quot;       &#123; TOKEN(TOKEN_INT); &#125;<br>&quot;return&quot;    &#123; TOKEN(TOKEN_RETURN); &#125;<br>&quot;if&quot;        &#123; TOKEN(TOKEN_IF); &#125;<br>&quot;else&quot;      &#123; TOKEN(TOKEN_ELSE); &#125;<br>&quot;for&quot;       &#123; TOKEN(TOKEN_FOR); &#125;<br>&quot;while&quot;     &#123; TOKEN(TOKEN_WHILE); &#125;<br>&quot;extern&quot;    &#123; TOKEN(TOKEN_EXTERN); &#125;<br>&quot;+&quot;         &#123; TOKEN(TOKEN_PLUS); &#125;<br>&quot;-&quot;         &#123; TOKEN(TOKEN_MINUS); &#125;<br>&quot;*&quot;         &#123; TOKEN(TOKEN_MUL); &#125;<br>&quot;/&quot;         &#123; TOKEN(TOKEN_DIV); &#125;<br>&quot;=&quot;         &#123; TOKEN(TOKEN_EQUAL); &#125;<br>&quot;==&quot;        &#123; TOKEN(TOKEN_CEQ); &#125;<br>&quot;!=&quot;        &#123; TOKEN(TOKEN_NLT); &#125;<br>&quot;&lt;&quot;         &#123; TOKEN(TOKEN_NLT); &#125;<br>&quot;&lt;=&quot;        &#123; TOKEN(TOKEN_NLE); &#125;<br>&quot;&gt;&quot;         &#123; TOKEN(TOKEN_NGT); &#125;<br>&quot;&gt;=&quot;        &#123; TOKEN(TOKEN_NGE); &#125;<br>&quot;^&quot;         &#123; TOKEN(TOKEN_XOR); &#125;<br>&quot;%&quot;         &#123; TOKEN(TOKEN_MOD); &#125;<br>&quot;&lt;&lt;&quot;        &#123; TOKEN(TOKEN_SHL); &#125;<br>&quot;&gt;&gt;&quot;        &#123; TOKEN(TOKEN_SHR); &#125;<br>&quot;&amp;&amp;&quot;        &#123; TOKEN(TOKEN_AND); &#125;<br>&quot;||&quot;        &#123; TOKEN(TOKEN_OR); &#125;<br>&quot;!&quot;         &#123; TOKEN(TOKEN_NOT); &#125;<br>&quot;;&quot;         &#123; TOKEN(TOKEN_SEMICOLON); &#125;<br>&quot;,&quot;         &#123; TOKEN(TOKEN_COMMA); &#125;<br>&quot;.&quot;         &#123; TOKEN(TOKEN_DOT); &#125;<br>&quot;(&quot;         &#123; TOKEN(LPAREN); &#125;<br>&quot;)&quot;         &#123; TOKEN(RPAREN); &#125;<br>&quot;[&quot;         &#123; TOKEN(LBRACKET); &#125;<br>&quot;]&quot;         &#123; TOKEN(RBRACKET); &#125;<br>&quot;&#123;&quot;         &#123; TOKEN(LBRACE); &#125;<br>&quot;&#125;&quot;         &#123; TOKEN(RBRACE); &#125;<br>&quot;#&quot;.*                   ;<br>[ \t\r\n];<br>[a-zA-Z_][a-zA-Z0-9_]*&#123; SAVE_TOKEN; return TOKEN_ID; &#125;<br>[0-9]+ &#123; SAVE_TOKEN; return NUM;&#125;<br><br>%%<br></code></pre></td></tr></table></figure><p>这个词法分析器匹配到结果后会传入在bison中定义的终结符。</p><p>上面我们定义了部分关键字, 由于这个语言只有一个类型，所以我就直接匹配”int”,如果要设计多个类型的话,这个变量类型可以全部列举出来或者直接跟那些标识符一起匹配,然后再设计类型系统。</p><p>设计好后我们就可以来准备中间代码生成了。<br>传送门：<a href="./CodeGen.md">中间代码生成</a></p>]]></content>
    
    
    <categories>
      
      <category>TinyToyCompiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>TinyToyCompiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyToyCompiler 语法及语法分析器</title>
    <link href="/2024/12/21/Syntax/"/>
    <url>/2024/12/21/Syntax/</url>
    
    <content type="html"><![CDATA[<h1 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h1><ul><li>本章节将介绍这个语言的语法定义和语法分析器的实现。</li><li>代码传送门: <a href="../../parser.y">parser.y</a></li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>这个语言的语法定义遵循C风格的语法,并做了大部分的删减。</p><ul><li>本语言只有<code>int</code>一种数据类型</li><li>语句后面不能有分号</li><li>标识符由字母、数字、下划线组成，且不能以数字开头，不能用关键字</li><li>流程控制、函数定义要求强制写大括号</li><li>注释以<code>#</code>开头，直到行末，不支持多行注释</li><li>…</li></ul><h2 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h2><table><thead><tr><th align="center">关键字</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">if</td><td align="center">else</td><td align="center">for</td></tr><tr><td align="center">while</td><td align="center">int</td><td align="center">return</td></tr><tr><td align="center">extern</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加法</td></tr><tr><td align="center">-</td><td align="center">减法</td></tr><tr><td align="center">*</td><td align="center">乘法</td></tr><tr><td align="center">&#x2F;</td><td align="center">除法</td></tr><tr><td align="center">%</td><td align="center">取模</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td></tr><tr><td align="center">&#x3D;</td><td align="center">赋值</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移位</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移位</td></tr><tr><td align="center">^</td><td align="center">按位异或</td></tr></tbody></table><h2 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a <br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a<br>    a = <span class="hljs-number">10</span><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="无参数函数"><a href="#无参数函数" class="headerlink" title="无参数函数"></a>无参数函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">return_ten</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有参数函数"><a href="#有参数函数" class="headerlink" title="有参数函数"></a>有参数函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="外部函数"><a href="#外部函数" class="headerlink" title="外部函数"></a>外部函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span><br></code></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span><br>    # 单个<span class="hljs-keyword">if</span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>) &#123;<br>        print(a)<br>    &#125;<br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>) &#123;<br>        print(a+a)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-meta"># <span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>-<span class="hljs-keyword">else</span></span><br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">10</span>) &#123;<br>        print(a + a + a)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">20</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span><br>    <span class="hljs-meta"># while</span><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br>        print(i)<br>        i = i + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-meta"># for</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i = i + <span class="hljs-number">1</span>) &#123;<br>        print(i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bison"><a href="#Bison" class="headerlink" title="Bison"></a>Bison</h2><p>本语言的语法定义使用了Bison进行语法分析。<br>网上可以找到很多关于Bison的教程，这里就不再赘述。<br>根据网络的信息，Bison的语法定义文件一般有以下部分：</p><ul><li>定义部分（Declarations）：包括头文件、宏定义和声明等。</li><li>语法元素：包括终结符、非终结符等。</li><li>规则部分（Rules）：定义语法规则，每个规则包括一个语法模式和对应的动作（用 C 语言编写）。</li><li>用户代码部分（User Code）：通常包含辅助函数、数据结构等，用于支持语法分析器的执行。</li></ul><h3 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h3><p>定义部分包括头文件、宏定义和声明等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bison">%&#123;<br>    #include &lt;iostream&gt;<br>    #include &lt;string&gt;<br>    #include &lt;stdio.h&gt;<br>    #include &quot;Node.h&quot;<br>    NBlock* root_program;<br>    extern int yylex();<br>    extern int yylineno;<br>void yyerror(const char* s)<br>&#123;<br>printf(&quot;Error: %s, line %d\n&quot;, s,yylineno);<br>        exit(1);<br>&#125;<br>%&#125;<br></code></pre></td></tr></table></figure><p>在<code>%&#123;</code>和<code>%&#125;</code>之间，我们定义了一些宏和头文件，并声明了一些全局变量。</p><h3 id="语法元素"><a href="#语法元素" class="headerlink" title="语法元素"></a>语法元素</h3><p>语法元素包括终结符、非终结符等。<br>在这里面定义的终结符将在后面的规则部分和词法分析器中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bison">%union&#123;<br>    NBlock* block;<br>    int token;<br>    Node* node;<br>    std::string* name;<br>    StmtAst* stmt;<br>    ExprAst* expr;<br>    NameAst* tkid;<br>    VarList* varvec;<br>std::vector&lt;shared_ptr&lt;ExprAst&gt;&gt;* exprvec;<br>    VarStmtAst* var_decl;<br>&#125;<br><br>%token &lt;token&gt; TOKEN_INT<br>%token &lt;token&gt; TOKEN_PLUS TOKEN_MINUS TOKEN_MUL TOKEN_DIV /*+ - * / */<br>%token &lt;token&gt; LPAREN RPAREN /*( ) */ LBRACKET RBRACKET /*[ ] */ LBRACE RBRACE /*&#123; &#125; */<br>%token &lt;token&gt; TOKEN_RETURN /*return*/ TOKEN_IF /*if*/ TOKEN_ELSE /*else*/ TOKEN_WHILE /*while*/ TOKEN_FOR /*for*/ TOKEN_EXTERN<br>...//此处省略n个规则<br>%token &lt;name&gt; TOKEN_ID NUM/*identifier*/<br><br><br>%type &lt;block&gt; program block stmts<br>%type &lt;exprvec&gt;  call_args <br>%type &lt;varvec&gt; func_decl_args<br>%type &lt;expr&gt;  expr assign<br>%type &lt;stmt&gt;  stmt if_stmt while_stmt for_stmt var_decl func_decl <br>%type &lt;tkid&gt;  tkid<br>%type &lt;token&gt; op<br><br>%left TOKEN_PLUS TOKEN_MINUS<br>%left TOKEN_MUL TOKEN_DIV TOKEN_MOD<br><br>%start program<br></code></pre></td></tr></table></figure><ul><li>在<code>%union&#123;...&#125;</code>中,我们定义了一些变量用来存储语法树的值。每个终结符和非终结符都可以与联合体中的某个字段关联。</li><li>在<code>%token &lt;token&gt;...</code>中，我们定义了所有的终结符。<br>其中的<code>&lt;token&gt;</code>这个字段是刚才在union中定义的变量名<code>int token</code>,表示这个终结符的值将存储在<code>token</code>这个字段中。由于这个语言没有太多的类型和关键字,我们就把这个类型定死了。</li><li>在<code>%type &lt;...&gt;</code>中，我们定义了非终结符的类型。<br><code>%type &lt;block&gt; program block stmts</code>表示<code>program</code>非终结符的类型为<code>block</code>的类型,即<code>NBlock*</code>。</li><li>在<code>%left...</code>中，我们定义了运算符的优先级。（这一个我并不是很理解,详细可以上网查）</li><li><code>%start program</code>表示程序的入口。</li></ul><h3 id="规则部分"><a href="#规则部分" class="headerlink" title="规则部分"></a>规则部分</h3><p>规则部分定义了语法规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bison">program : stmts &#123; root_program = $1; &#125;<br>stmts : stmt &#123; $$ = new NBlock();  $$-&gt;stmts-&gt;push_back(shared_ptr&lt;StmtAst&gt;($1));  &#125;<br>    | stmts stmt &#123; $1-&gt;stmts-&gt;push_back(shared_ptr&lt;StmtAst&gt;($2)); $$ = $1; &#125;<br>stmt : var_decl &#123; $$ = $1; &#125;<br>    | func_decl &#123; $$ = $1; &#125;<br>    | expr &#123;$$ = new ExprStmtAst(shared_ptr&lt;ExprAst&gt;($1));&#125;<br>    | TOKEN_RETURN expr &#123;$$ = new ReturnStmtAst(shared_ptr&lt;ExprAst&gt;($2));&#125;<br>    | if_stmt &#123; $$ = $1; &#125;<br>    | for_stmt &#123; $$ = $1; &#125;<br>    | while_stmt &#123; $$ = $1; &#125;<br><br>block : LBRACE stmts RBRACE &#123; $$ = $2; &#125;<br>    | LBRACE RBRACE &#123; $$ = new NBlock(); &#125;<br><br>var_decl : TOKEN_INT tkid &#123; $$ = new VarStmtAst(TOKEN_INT, shared_ptr&lt;NameAst&gt;($2)); &#125;<br>    | TOKEN_INT tkid TOKEN_EQUAL  expr &#123; $$ = new VarStmtAst(TOKEN_INT, shared_ptr&lt;NameAst&gt;($2), shared_ptr&lt;ExprAst&gt;($4)); &#125;<br>    | error &#123; std::cout &lt;&lt; &quot;Error: Invalid variable declaration\n&quot;; &#125;<br>...//此处省略n个规则<br></code></pre></td></tr></table></figure><p>我个人的理解是：<br>传进来的token将匹配到对应的语法,一步一步递归下降一直到终结符。<br>其中又有一个部分和前面的<code>%union</code>有关：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bison">func_decl_args : /* blank */ &#123; $$ = new VarList(); &#125;<br>| var_decl &#123; $$ = new VarList(); $$-&gt;push_back(shared_ptr&lt;VarStmtAst&gt;($&lt;var_decl&gt;1)); &#125;<br>| func_decl_args TOKEN_COMMA var_decl &#123; $1-&gt;push_back(shared_ptr&lt;VarStmtAst&gt;($&lt;var_decl&gt;3)); &#125;<br></code></pre></td></tr></table></figure><p>其中有个<code>$&lt;var_decl&gt;1</code>和<code>$&lt;var_decl&gt;3</code>,根据自己的理解和查阅的资料得出：<br><code>$&lt;var_decl&gt;3</code> 显示该位置的值应当被视作 <code>var_decl</code> 类型。用容易理解的话来说就是把这个<code>$3</code>变成<code>var_decl</code>类型的值。</p><p>具体的语法规则我就不一一列举了，可以参考: <a href="../../parser.y">parser.y</a></p><p>下一个章节我们要介绍词法分析器。<br>传送门: <a href="Lexer.md">词法分析器</a></p>]]></content>
    
    
    <categories>
      
      <category>TinyToyCompiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>TinyToyCompiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyToyCompiler AST节点</title>
    <link href="/2024/12/21/AST/"/>
    <url>/2024/12/21/AST/</url>
    
    <content type="html"><![CDATA[<h1 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h1><ul><li>本章节我们将介绍这个语言的AST</li><li>代码传送门:<a href="../../Node.h">Node.h</a></li></ul><p>由于在语法分析器中我们需要生成AST,所以我们先讲AST节点的相关内容。</p><h2 id="AST（Abstract-Syntax-Tree，抽象语法树）"><a href="#AST（Abstract-Syntax-Tree，抽象语法树）" class="headerlink" title="AST（Abstract Syntax Tree，抽象语法树）"></a>AST（Abstract Syntax Tree，抽象语法树）</h2><p>根据网络内容：<br>AST是一种树形结构，它将源代码的语法结构表示为一系列嵌套的节点。每个节点代表源代码中的一个语法元素，例如表达式、语句、函数定义、变量声明等。AST的每个节点都有一组属性，这些属性描述了该节点的语法特征。<br>AST的目的是为了方便进行代码分析和转换。它可以帮助我们理解代码的结构、检查代码的正确性、生成代码的不同表示形式（例如，将代码转换为机器代码或优化代码）。</p><h2 id="AST节点的定义"><a href="#AST节点的定义" class="headerlink" title="AST节点的定义"></a>AST节点的定义</h2><p>AST的节点可以分为以下几类：</p><ul><li>表达式节点：包括变量、函数调用、算术运算、逻辑运算、赋值表达式等。</li><li>语句节点：包括条件语句、循环语句、变量声明、赋值语句、表达式语句等。</li><li>代码块节点：包括函数定义、条件语句块、循环语句块等。<br>我们实现一个根节点Node来作为所有AST节点的基类:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Node</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> llvm::Value* <span class="hljs-title">codeGen</span><span class="hljs-params">(CodeGenContext&amp; context)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>这个codegen函数将在后面生成中间代码时使用。</li></ul><p>由于AST节点可以分为表达式和语句还有代码块,我们就为这些类分别定义基类ExprAst、StmtAst、NBlock:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExprAst</span> : <span class="hljs-keyword">public</span> Node&#123;&#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StmtAst</span> : <span class="hljs-keyword">public</span> Node&#123;&#125; ;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NBlock</span> : <span class="hljs-keyword">public</span> Node &#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;StmtList&gt; stmts = <span class="hljs-built_in">make_shared</span>&lt;StmtList&gt;();<br>    <span class="hljs-built_in">NBlock</span>()&#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> llvm::Value* <span class="hljs-title">codeGen</span><span class="hljs-params">(CodeGenContext&amp; context)</span> <span class="hljs-keyword">override</span></span>; <br>&#125;;<br></code></pre></td></tr></table></figure><p>定义OK之后,我们就可以开始实现具体的节点了。<br><code>例子</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumAst</span> : <span class="hljs-keyword">public</span> ExprAst &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-built_in">NumAst</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value</span>(value) &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> llvm::Value* <span class="hljs-title">codeGen</span><span class="hljs-params">(CodeGenContext&amp; context)</span> <span class="hljs-keyword">override</span></span>; <br>&#125;;<br></code></pre></td></tr></table></figure><p>每个节点类都实现一个构造函数并声明一个<code>codeGen</code>函数,这个函数的实现将在后面介绍。<br>具体的实现可以参考<a href="../../Node.h">Node.h</a></p><p>下一章节我们将介绍语法分析器的实现。<br>传送门：<a href="Syntax.md">语法分析器实现</a></p>]]></content>
    
    
    <categories>
      
      <category>TinyToyCompiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>TinyToyCompiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TinyToyCompiler 开发手册</title>
    <link href="/2024/12/21/main/"/>
    <url>/2024/12/21/main/</url>
    
    <content type="html"><![CDATA[<h1 id="TinyToyCompiler-开发手册"><a href="#TinyToyCompiler-开发手册" class="headerlink" title="TinyToyCompiler 开发手册"></a>TinyToyCompiler 开发手册</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>这个文档是TinyToyCompiler 开发手册，记录了自己的一些心得，也便于自己或他人对这个编译器进行修改，对于入门编译器的一些萌新给予一些启示。</p><h2 id="语言简介"><a href="#语言简介" class="headerlink" title="语言简介"></a>语言简介</h2><p>这个语言是采用Flex+Bison+LLVM9编写的一个C风格的小型语言。这个语言有如下特点：</p><ul><li>只有int整数一种数据类型</li><li>语句后面不用带分号</li><li>源代码开放，易于扩展</li><li>…还有众多特点等着你去细细品味</li></ul><h2 id="编译的一般过程"><a href="#编译的一般过程" class="headerlink" title="编译的一般过程"></a>编译的一般过程</h2><p>一段代码的编译一般要经过<code>词法分析-&gt;语法分析-&gt;语义分析-&gt;中间代码生成-&gt;优化-&gt;生成目标代码</code>的过程。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>根据网络上百科的内容：词法分析是计算机科学中将字符序列转换为单词序列的过程。进行词法分析的程序或者函数叫作词法分析器<br>简单来说就是把你输入的代码分成一个一个的单词。</p><p>网络上有很多实现词法分析器的方法，例如自己编写正则表达式、编写一个状态机，或者是使用一些工具。在本项目中我们使用的是Flex工具来生成词法分析器。</p><p>例子：<a href="https://docs.python.org/zh-cn/3.13/library/re.html#writing-a-tokenizer">正则表达式写一个词法分析器</a></p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>根据网络上百科的内容：语法分析是编译过程的一个逻辑阶段。语法分析的任务是在词法分析的基础上将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等.语法分析程序判断源程序在结构上是否正确.源程序的结构由上下文无关文法描述.</p><p>语法分析器的输出是一棵抽象语法树（Abstract Syntax Tree，AST）。AST是一种树状结构，它将源程序的语法结构表示出来。AST的每个节点都代表着源程序中的一个语法短语。AST的根节点代表着整个程序。</p><p>在本项目中我们使用的是Bison工具来生成语法分析器。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析是编译过程的一个阶段。语义分析的任务是对源程序进行静态分析，以确定程序的语义正确性。<br>语义分析可能进行着类似于变量类型检查，作用域分析之类的操作。<br>由于本项目的语言只有一种数据类型，所以将语义分析这一部分去掉了。也就没有定义类型系统。</p><h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>中间代码生成是编译过程的一个阶段。中间代码生成的任务是将源程序的语法结构转换成中间代码（如LLVM IR）。<br>本项目使用LLVM IR作为中间代码。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化是编译过程的一个阶段。优化的任务是对中间代码进行优化，以提高代码的运行效率。<br>优化可能包括常量折叠、死代码消除、循环展开、寄存器分配、代码调度等等。</p><h3 id="生成目标代码"><a href="#生成目标代码" class="headerlink" title="生成目标代码"></a>生成目标代码</h3><p>生成目标代码是编译过程的一个阶段。生成目标代码的任务是将中间代码转换成目标代码（如汇编语言）。</p><p>由于在语法分析器中我们需要生成AST,所以我们先讲AST节点的相关内容。<br>下一个章节我们将从AST节点的设计开始。<br>传送门: <a href="AST.md">AST节点设计</a></p>]]></content>
    
    
    <categories>
      
      <category>TinyToyCompiler</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译器</tag>
      
      <tag>TinyToyCompiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode35——搜索插入位置</title>
    <link href="/2024/06/02/Leetcode35/"/>
    <url>/2024/06/02/Leetcode35/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode35-搜索插入位置"><a href="#LeetCode35-搜索插入位置" class="headerlink" title="LeetCode35 搜索插入位置"></a>LeetCode35 搜索插入位置</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs md">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br><br>请必须使用时间复杂度为 O(log n) 的算法。<br><br> <br><br>示例 1:<br><br>输入: nums = [1,3,5,6], target = 5<br>输出: 2<br>示例 2:<br><br>输入: nums = [1,3,5,6], target = 2<br>输出: 1<br>示例 3:<br><br>输入: nums = [1,3,5,6], target = 7<br>输出: 4<br> <br><br>提示:<br><br>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为 无重复元素 的 升序 排列数组<br>-104 &lt;= target &lt;= 104<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题采用二分查找法,通过维护left right 和 mid指针才查找</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><p>本题容易将left 和right指针边界弄错</p><h2 id="参考题解-CPP"><a href="#参考题解-CPP" class="headerlink" title="参考题解(CPP)"></a>参考题解(CPP)</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">/*初始化指针*/</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> ;<span class="hljs-comment">//注意，此处要减1</span><br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span> (left&lt;=right)&#123; <span class="hljs-comment">//如果right 是nums.size()-1的话要记得left是&lt;=</span><br>            <br>        mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//判断当中指针的值等于目标直接返回下标</span><br>        <span class="hljs-keyword">if</span> (nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-comment">//如果中间指针的值小于目标值,剔除左边部分</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//同理,如果中间指针的值大于目标值,剔除右边部分</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当left &gt; right 时,返回left,left就是插入位置的下标</span><br>    <span class="hljs-keyword">return</span> left ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-comment">/*初始化指针*/</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()  ;<span class="hljs-comment">//注意，此处不要减1</span><br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span> (left&lt;=right)&#123; <span class="hljs-comment">//如果right 是nums.size()的话要记得left是&lt;</span><br>            <br>        mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//判断当中指针的值等于目标直接返回下标</span><br>        <span class="hljs-keyword">if</span> (nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-comment">//如果中间指针的值小于目标值,剔除左边部分</span><br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//同理,如果中间指针的值大于目标值,剔除右边部分</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//当left &gt; right 时,返回left,left就是插入位置的下标</span><br>    <span class="hljs-keyword">return</span> left ;<br>&#125;<br></code></pre></td></tr></table></figure><p>over!!!</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>二分查找</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好</title>
    <link href="/2024/04/14/%E4%BD%A0%E5%A5%BD/"/>
    <url>/2024/04/14/%E4%BD%A0%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="博客站开放啦！"><a href="#博客站开放啦！" class="headerlink" title="博客站开放啦！"></a>博客站开放啦！</h1><h2 id="今天，这个博客站搭建完成"><a href="#今天，这个博客站搭建完成" class="headerlink" title="今天，这个博客站搭建完成"></a>今天，这个博客站搭建完成</h2><h3 id="about"><a href="#about" class="headerlink" title="about"></a>about</h3><ul><li>email: <a href="mailto:&#x74;&#x69;&#x61;&#110;&#x68;&#x75;&#122;&#x6f;&#110;&#103;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#x74;&#x69;&#x61;&#110;&#x68;&#x75;&#122;&#x6f;&#110;&#103;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;</a></li><li>github: <a href="https://github.com/tianhuzong">tianhuzong</a></li><li>爱发电 : <a href="https://afdian.net/a/thzsen">thzsen</a></li><li>bilibili : <a href="https://space.bilibili.com/3494354284972407">天狐宗仙</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
